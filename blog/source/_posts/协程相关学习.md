---
title: 协程相关学习
date: 2019-05-09 11:12:06
tags:
---
以下内容抄自：[Unity3d IEnumerator 协程的理解](https://blog.csdn.net/jasonwang18/article/details/55519165)
#### 协程是什么
从程序结构的角度来讲，协程是一个有限状态机，这样说可能并不是很明白，说到协程（Coroutine），我们还要提到另一样东西，那就是子例程（Subroutine），子例程一般可以指函数，函数是没有  状态 的，等到它return之后，它的所有局部变量就消失了，但是在协程中我们可以在  一个函数里多次返回， 局部变量被当作状态保存在协程函数中，知道最后一次return，协程的状态才别清除。 

简单来说，协程就是：你可以写一段顺序的代码，然后标明哪里需要暂停，然后在下一帧或者一段时间后，系统会继续执行这段代码。

#### 协程怎么用？
一个简单的C#代码，如下：
```c#
IEnumerator LongComputation()
{
    while(someCondition)
    {
        /* 做一系列的工作 */
 
        // 在这里暂停然后在下一帧继续执行
        yield return null;
    }
}
```
#### 协程是怎么工作的

注意上边的代码示例，你会发现一个协程函数的返回值是**IEnumerator，它是一个迭代器，你可以把它当成指向一个序列的某个节点的指针 **。它提供了两个重要的接口，分别是**Current（返回当前指向的元素）和MoveNext()（将指针向前移动一个单位，如果移动成功，则返回true）**。

通常，如果你想实现一个接口，你可以写一个类，实现成员，等等。  迭代器块（iterator block） 是一个方便的方式实现IEnumerator没有任何麻烦-你只是遵循一些规则，并实现IEnumerator由编译器自动生成。 

##### 一个迭代器块具备如下特征：

1. 返回IEnumerator
2. 使用yield关键字

所以yield关键词是干啥的？**它声明序列中的下一个值或者是一个无意义的值。如果使用yield x（x是指一个具体的对象或数值）的话，那么movenext返回为true并且current被赋值为x，如果使用yield break使得movenext()返回false**。