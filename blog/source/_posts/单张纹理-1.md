---
title: 单张纹理
tags: []
id: '36'
categories:
  - - 纹理
date: 2019-06-07 16:25:15
---

### 《Unity Shader 入门精要》学习记录

在贴纹理的shader中，我们要在Cg代码片中为纹理类型的属性声明一个float4类型的变量 \_MainTex\_ST。**在Unity中，使用 纹理名\_ST的方式来生命某个纹理的属性。**  
其中，ST是缩放和平移的缩写，\_MainTex\_ST可以让我们得到该纹理的缩放和平移值，\_MainTex\_ST.xy 是**缩放**,\_MainTex\_ST.zw是偏移值，我们可以在面板的纹理属性中调节

* * *

在UnityShader入门精要这本书中的例子里，定义了从应用到顶点着色器中包含的 第一组纹理坐标， float4 texcoord : TEXCOORD0; 然后又定义了从顶点着色器到片元着色器中的变量 float2 uv : TEXCOORD2;以便在片元着色器中使用该坐标进行纹理采样  
uv的计算是： uv = v.texcoord.xy \* \_MainTex\_ST.xy + \_MainTex\_ST.zw; 其中，v.texcoord.xy 是当前顶点对应的纹理坐标？，然后使用 纹理的 \_MainTex\_ST.xy 对坐标进行缩放，然后再使用偏移属性 \_MainTex\_ST.zw对结果进行偏移。不过这个式子可以使用unity自带的 uv = TRANSFORM\_TEX(v.texcoord, \_MainTex\_ST) 进行省略计算

* * *

书中例子，注意，一下代码未放到unity中进行试验，仅将书中内容打一遍

```
Shader "Unity Shaders Book/Chapter 7/Siginle Texture" {
  Properties {
    _Color ("Color Tint", Color) = (1, 1, 1, 1)
    _MainTex ("Main Tex", 2D) = "white" {}
    _Specular ("Specular", Color) = (1, 1, 1, 1)
    _Gloss ("Gloss", Range(8.0, 256)) = 20
  }
  SubShader {
    Pass {
      Tags {"LightMode" = "ForwardBase"}
      CGPROGRAM

      #pragma vertex vert
      #pragma fragment frag

      #include "Lighting.cginc"

      fixed4 _Color;
      sampler2D _MainTex; // 对应的是Properties中的_MainTex
      float4 _MainTex_ST; // 直接声明，用来表示 _MainTex 这个纹理的属性，xy为缩放值，zw为偏移值
      fixed4 _Specular;
      float _Gloss; // 高光反射中使用的幂

      struct a2v {
        float4 vertex : POSITION;
        float3 normal : NORMAL;
        float4 textcoord : TEXCOORD0;
      };

      // 创建用于从 顶点着色器 向 片元着色器 通信
      struct v2f {
        float4 pos : SV_POSITION;
        float3 worldNormal : TEXCOORD0; // 看来这个0 和下面的 1 都是针对当前数据结构的，也就是说，和上面的a2v没太多关系
        float3 worldPos : TEXCOORD1;
        float2 uv : TEXCOORD2;  // 存储最终计算出的纹理坐标，以便在片元着色器中使用坐标进行纹理采样
      };

      v2f vert(a2v v) {
        v2f o;
        // 计算顶点在裁剪空间中的位置
        o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
        // 获取法线在世界坐标系中的表现形式
        o.worldNormal = UnityObjectToWorldNormal(v.normal);
        // 获得顶点在世界坐标系中的位置
        o.worldPos = mul(_Object2World, v.vertex).xyz
        o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw
        // 在这里，计算uv可以通过unity内置方法来解决
        // o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);  // 此处的 _MainTex 指的是上面我们在Properties中定义的纹理变量
        return o;
      }

      fixed4 frag(v2f i) : SV_Target {
        fixed3 worldNormal = normalize(i.worldNormal);
        // 获得世界空间中的光照方向
        fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos))

        // Use the texture to sample the diffuse color
        // 获得贴图中的颜色，取样用来做漫反射光照（漫反射颜色，可以理解为，在漫反射的情况下，加之自身颜色的作用，的最终值）
        // albedo 意为 反射率，漫反射系数
        fixed3 albedo = text2D(_MainTex, i.uv).rgb * _Color.rgb;

        // 环境光，由 环境光 与 albedo 相乘，得到其环境光部分。
        fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;

        // 计算得出漫反射颜色
        fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));

        // 获得高光反射值，使用的是 Blinn-Phong高光模型
        // 观察方向， r向量
        fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));
        // 使用的是Blinn-Phong模型中的 half，计算的是 观察方向和光源方向相加的归一化
        fixed3 halfDir = normalize(worldLightDir + viewDir);
        // 计算高光反射内容
        fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);

        return fixed4(ambient + diffuse + specular, 1.0);
      }
    }
  }
}
```